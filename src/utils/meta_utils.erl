% Copyright (C) 2014 Olivier Boudeville
%
% This file is part of the Ceylan Erlang library.
%
% This library is free software: you can redistribute it and/or modify
% it under the terms of the GNU Lesser General Public License or
% the GNU General Public License, as they are published by the Free Software
% Foundation, either version 3 of these Licenses, or (at your option)
% any later version.
% You can also redistribute it and/or modify it under the terms of the
% Mozilla Public License, version 1.1 or later.
%
% This library is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
% GNU Lesser General Public License and the GNU General Public License
% for more details.
%
% You should have received a copy of the GNU Lesser General Public
% License, of the GNU General Public License and of the Mozilla Public License
% along with this library.
% If not, see <http://www.gnu.org/licenses/> and
% <http://www.mozilla.org/MPL/>.
%
% Author: Olivier Boudeville (olivier.boudeville@esperide.com)
% Creation date: Friday, December 19, 2014




% Gathering of various convenient meta-related facilities, notably regarding
% metaprograming and parse transforms.
%
% See meta_utils_test.erl for the corresponding test.
%
% Note that this module is a prerequisite of parse transforms, hence it must be
% bootstrapped before they are built, and cannot use them.
%
% So, to compile it, just go to the root of this layer and execute for example
% 'make all'.
%
-module(meta_utils).



% Implementation notes:

% Some resources to better understand parse transforms (PT, here):
%
% - generic information about PT: in http://www.erlang-factory.com/ :
% upload/presentations/521/yrashk_parse_transformations_sf12.pdf
%
% - Abstract Format: http://www.erlang.org/doc/apps/erts/absform.html
%
% - http://chlorophil.blogspot.fr/2007/04/erlang-macro-processor-v1-part-i.html
%   http://chlorophil.blogspot.fr/2007/04/atomiser-part-ii.html
%   http://chlorophil.blogspot.fr/2007/04/atomiser-part-iii.html
%   http://chlorophil.blogspot.fr/2007/04/atomiser-part-iv.html
%   http://chlorophil.blogspot.fr/2007/04/atomiser-part-v.html
%   http://chlorophil.blogspot.fr/2007/04/atomiser-part-vi.html
%   http://chlorophil.blogspot.fr/2007/04/atomiser-part-vii.html


% Standard modules of interest:
%
% - erl_scan ('The Erlang Token Scanner'): functions for tokenizing characters
% into Erlang tokens
%
% - epp ('An Erlang Code Preprocessor'): functions which are used by compile to
% preprocess macros and include files before the actual parsing
%
% - erl_parse ('The Erlang Parser'): basic Erlang parser
%
% - erl_eval ('The Erlang Meta Interpreter'): interpreter for Erlang
% expressions, in the abstract syntax
%
% - erl_pp ('The Erlang Pretty Printer'): to display abstract forms
%
% - erl_lint ('The Erlang Code Linter'): to check Erlang code for illegal
% syntax, bugs, unrecommended coding practices, etc.
%
% - compile ('The Erlang Compiler'): interface to the standard Erlang compiler

% Example of PT: http://www.erlang.org/doc/man/erl_id_trans.html


% Third-party libraries of interest:
%
% - https://github.com/uwiger/parse_trans
% - https://github.com/uwiger/toker


% Useful information:
%
% - how to convert source code into actual code: on
% http://stackoverflow.com/questions/,
% 2160660/how-to-compile-erlang-code-loaded-into-a-string


% Use -P to see the code generated by a parse-transform; ex: 'erlc -P' or in the
% shell as 'c("X.erl", [ 'P' ] )".



% For function_info:
-include("meta_utils.hrl").


% Type-related section.


% Line-related location in a source file:
-type file_loc() :: er_scan:location().


% Abstract Syntax Tree, standard representation of parse trees for Erlang
% programs as Erlang terms. This representation is known as the abstract
% format.
%
% For more information: http://www.erlang.org/doc/apps/erts/absform.html
%
-type ast() :: erl_parse:abstract_form().


% The name of a (parse-level) attribute (ex: '-my_attribute( my_value ).').
%
-type attribute_name() :: atom().


% The value of a (parse-level) attribute (ex: '-my_attribute( my_value ).').
%
-type attribute_value() :: term().



% Parse-level attribute:
%
-type attribute() :: { attribute_name(), attribute_value() }.



% The name of a function:
%
-type function_name() :: basic_utils:function_name().


% Declaration of a function based on a name with an arity (unique function
% signature within a module):
%
-type function_id() :: { function_name(), arity() }.


% The form corresponding to the definition of a clause of a function:
%
-type clause_def() :: ast().


% The type definition (if any) of that function, as an abstract form:
-type function_spec() :: ast().


% Describes a function.
%
-record( function_info, {

		   % The name of that function:
		   name = undefined :: function_name(),

		   % The arity of that function:
		   arity = undefined :: arity(),

		   % The abstract form of its definition (if any):
		   definition = undefined :: [ clause_def() ],

		   % The type definition (if any) of that function, as an abstract form:
		   spec_def = undefined :: function_spec(),

		   % Tells whether this function is exported by its defining module:
		   is_exported = undefined :: boolean()

} ).

-type function_info() :: #function_info{}.



% Describes the name of a type (without the number of the types it depends on,
% for polymorphic ones).
%
-type type_name() :: atom().


% Number of types a (possibly polymorphic) type depends on (possibly zero for
% plain types).
%
-type type_arity() :: basic_utils:count().


% The "most precise" description of a primitive, simple type (ex: 'boolean' and
% 'atom' coexist, 'number ' are not used), etc.
%
-type type_description() :: 'atom' | 'binary' | 'boolean' | 'float' | 'function'
						  | 'integer' | 'list' | 'pid' | 'port' | 'record'
						  | 'reference' | 'tuple'.


% Description of a type:
-type type() :: term().


% Type of functions to transform terms during a recursive traversal (see
% traverse_term/4).
%
% Note: apparently we cannot use the 'when' notation here (InputTerm ... when
% InputTerm :: term()).
%
-type term_transformer() :: fun( ( term(), basic_utils:user_data() ) ->
									   { term(), basic_utils:user_data() } ).


-export_type([ file_loc/0, ast/0,
			   attribute_name/0, attribute_value/0, attribute/0,
			   function_name/0, function_id/0,
			   clause_def/0, function_spec/0, function_info/0,
			   type_name/0, type_arity/0, type_description/0, type/0,
			   term_transformer/0
			 ]).



% Parse-transform related functions:

-export([ function_info_to_string/1, get_type_of/1, traverse_term/4,
		  form_to_ast/1, form_to_ast/2, term_to_ast/1, term_to_ast/2,
		  raise_error/1 ]).


% Returns a textual description of the specified function information.
%
-spec function_info_to_string( function_info() ) -> text_utils:ustring().
function_info_to_string( #function_info{
		   name=Name,
		   arity=Arity,
		   definition={ function, _Line, _Name, _Arity, Clauses },
		   spec=Spec
						   } ) ->

	DefString = case Clauses of

					undefined ->
						"no definition";

					_ ->
						io_lib:format( "~B clauses defined", [ length( Clauses ) ] )

	end,

	SpecString = case Spec of

					 undefined ->
						 "no type specification";

					 _ ->
						 "a type specification"

	end,

	io_lib:format( "~s/~B with ~s and ~s", [ Name, Arity, DefString, SpecString ] ).



% Returns an atom describing, as precisely as possible, the type of the
% specified term.
%
% 'is_num', 'is_record', etc. not usable here.
%
-spec get_type_of( term() ) -> type_description().
get_type_of( Term ) when is_boolean( Term ) ->
	'boolean';

get_type_of( Term ) when is_atom( Term ) ->
	'atom';

get_type_of( Term ) when is_binary( Term ) ->
	'binary';

get_type_of( Term ) when is_float( Term ) ->
	'float';

get_type_of( Term ) when is_function( Term ) ->
	'function';

get_type_of( Term ) when is_integer( Term ) ->
	'integer';

get_type_of( Term ) when is_pid( Term ) ->
	'pid';

get_type_of( Term ) when is_list( Term ) ->
	'list';

get_type_of( Term ) when is_port( Term ) ->
	'port';

%get_type_of( Term ) when is_record( Term ) ->
%	'record';

get_type_of( Term ) when is_tuple( Term ) ->
	'tuple';

get_type_of( Term ) when is_reference( Term ) ->
	'reference'.




% Traverses specified term (possibly with nested subterms - the function will
% recurse in lists and tuples), calling specified transformer function on each
% instance of specified type, in order to replace that instance by the result of
% that function.
%
% Returns an updated term, with these replacements made.
%
% Ex: the input term could be T={ a, [ "foo", { c, [ 2.0, 45 ] } ] } and the
% function might replace, for example, floats by <<bar>>; then T'={ a, [ "foo",
% { c, [ <<bar>>, 45 ] } ] } would be returned.
%
% Note: the transformed terms are themselves recursively transformed, to ensure
% nesting is managed. Of course this implies that the term transform should not
% result in iterating the transformation infinitely.
%
-spec traverse_term( term(), type_description(), term_transformer(),
			 basic_utils:user_data() ) -> { term(), basic_utils:user_data() }.

% Here the term is a list and this is the type we want to intercept:
traverse_term( TargetTerm, _TypeDescription=list, TermTransformer, UserData )
  when is_list( TargetTerm ) ->

	{ TransformedTerm, NewUserData } = TermTransformer( TargetTerm, UserData ),

	traverse_transformed_term( TransformedTerm, _TypeDescription=list,
							   TermTransformer, NewUserData );


% Here the term is a list and we are not interested in them:
traverse_term( TargetTerm, TypeDescription, TermTransformer, UserData )
  when is_list( TargetTerm ) ->

	traverse_list( TargetTerm, TypeDescription, TermTransformer, UserData );


% Here the term is a tuple (or a record...), and we want to intercept them:
traverse_term( TargetTerm, TypeDescription, TermTransformer, UserData )
  when is_tuple( TargetTerm )
	andalso ( TypeDescription =:= tuple orelse TypeDescription =:= record ) ->

	{ TransformedTerm, NewUserData } = TermTransformer( TargetTerm, UserData ),

	traverse_transformed_term( TransformedTerm, TypeDescription,
							   TermTransformer, NewUserData );


% Here the term is a tuple (or a record...), and we are not interested in them:
traverse_term( TargetTerm, TypeDescription, TermTransformer, UserData )
  when is_tuple( TargetTerm ) ->

	traverse_tuple( TargetTerm, TypeDescription, TermTransformer, UserData );


% Base case (current term is not a binding structure, it is a leaf of the
% underlying syntax tree):
%
traverse_term( TargetTerm, TypeDescription, TermTransformer, UserData ) ->

	case get_type_of( TargetTerm ) of

		TypeDescription ->
			TermTransformer( TargetTerm, UserData );

		_ ->
			% Unchanged:
			{ TargetTerm, UserData }

	end.



% Helper to traverse a list.
%
traverse_list( TargetList, TypeDescription, TermTransformer, UserData ) ->

	{ NewList, NewUserData } = lists:foldl( fun( Elem, { AccList, AccData } ) ->

			{ TransformedElem, UpdatedData } = traverse_term( Elem,
							TypeDescription, TermTransformer, AccData ),

			% New accumulator, produces a reversed element list:
			{ [ TransformedElem | AccList ], UpdatedData }

											end,

											_Acc0={ _Elems=[], UserData },

											TargetList ),

	{ lists:reverse( NewList ), NewUserData }.



% Helper to traverse a tuple.
%
traverse_tuple( TargetTuple, TypeDescription, TermTransformer, UserData ) ->

	% We do exactly as with lists:
	TermAsList = tuple_to_list( TargetTuple ),

	{ NewList, NewUserData } = traverse_list( TermAsList, TypeDescription,
											  TermTransformer, UserData ),

	{ list_to_tuple( NewList ), NewUserData }.



% Helper to traverse a transformed term (ex: if looking for a { user_id, String
% } pair, we must recurse in nested tuples like: { 3, { user_id, "Hello" }, 1 }.
traverse_transformed_term( TargetTerm, TypeDescription, TermTransformer,
						   UserData ) ->

	case TermTransformer( TargetTerm, UserData ) of

		{ TransformedTerm, NewUserData } when is_list( TransformedTerm ) ->
			traverse_list( TransformedTerm, TypeDescription, TermTransformer,
						   NewUserData );

		{ TransformedTerm, NewUserData } when is_tuple( TransformedTerm ) ->
			traverse_tuple( TransformedTerm, TypeDescription, TermTransformer,
						   NewUserData );

		% { ImmediateTerm, NewUserData } ->
		Other ->
			Other

	end.



% Section to generate AST.


% Converts the specified source code of a form into its corresponding abstract
% form.
%
% Ex: form_to_ast( "f() -> hello_world." ) returns
%   { function, 1, f, 0, [ { clause, 1, [], [], [ {atom,1,hello_world} ] } ] }
%
-spec form_to_ast( string() ) -> ast().
form_to_ast( FormString ) ->
	form_to_ast( FormString, _Loc=1 ).


% Converts the specified source code of a form into its corresponding abstract
% form.
%
% Ex: form_to_ast( "f() -> hello_world." ) returns
%   { function, 1, f, 0, [ { clause, 1, [], [], [ {atom,1,hello_world} ] } ] }
%
-spec form_to_ast( string(), file_loc() ) -> ast().
form_to_ast( FormString, Location ) ->

	% First get Erlang tokens from that string:
	Tokens = case erl_scan:string( FormString, Location ) of

		% Ex: [{atom,1,f},{'(',1},{')',1},{'->',1},{atom,1,hello_world},{dot,1}]
		{ ok, Toks, _EndLocation } ->
			%io:format( "Tokens: ~p~n", [ Toks ] ),
			Toks;

		ErrorTok ->
			throw( { form_tokenizing_error, FormString, ErrorTok } )

	end,

	% Tokens to erl_parse trees:

	case erl_parse:parse_form( Tokens ) of

			  { ok, ParseTree } ->
				  ParseTree;

			  ErrorPar ->
				  throw( { form_parsing_error, FormString, ErrorPar } )

	end.



% Converts the specified source code of a term into its corresponding abstract
% form.
%
% Ex: term_to_ast( "[ { a, 1 }, foobar ]" ) returns
%   [ { cons, 1, { tuple, 1, [ {atom,1,a}, {integer,1,1} ] },
%     { cons, 1, {atom,1,foobar}, {nil,1} } } ]
%
-spec term_to_ast( string() ) -> ast().
term_to_ast( TermString ) ->
	term_to_ast( TermString, _Loc=1 ).


term_to_ast( TermString, Location ) ->

	% First get Erlang tokens from that string:
	Tokens = case erl_scan:string( TermString, Location ) of

		% Ex: [ {'[',1}, {'{',1}, {atom,1,a}, {',',1}, {integer,1,1}, {'}',1},
		% {',',1}, {atom,1,foobar}, {']',1} ]
		{ ok, Toks, _EndLocation } ->
			%io:format( "Tokens: ~p~n", [ Toks ] ),
			Toks;

		ErrorTok ->
			throw( { term_tokenizing_error, TermString, ErrorTok } )

	end,

	% Tokens to erl_parse trees:

	case erl_parse:parse_exprs( Tokens ) of

			  { ok, ParseTree } ->
				  ParseTree;

			  ErrorPar ->
				  throw( { term_parsing_error, TermString, ErrorPar } )

	end.



% Used to be a simple throw, but then for parse transforms the error message was
% garbled in messages like:
%
% """
% internal error in lint_module;
% crash reason: function_clause
%
%  in function  erl_lint:'-compiler_options/1-lc$^0/1-0-'/1
%     called as erl_lint:'-compiler_options/1-lc$^0/1-0-'({
% table_type_defined_more_than_once,{line,12},foo_hashtable,bar_hashtable})
%
-spec raise_error( term() ) -> no_return().
raise_error( ErrorTerm ) ->

	%throw( ErrorTerm )
	%io:format( "~n~n*** Error: ~p.~n", [ ErrorTerm ] ),
	erlang:exit( ErrorTerm ).
