/*
 * Most simple fragment shader.
 *
 * Each fragment shader instance is to transform exactly one fragment (as
 * generated by the rasterization) into another that is based on a series of
 * colors and a single depth value.
 *
 * At least generally, this transformation should behave as a pure
 * (context-free) function.
 *
 * Refer to https://www.khronos.org/opengl/wiki/Fragment_Shader for more
 * information.
 *
 */


/*
 * The GLSL version now matches the one of OpenGL (3.3);
 * using the (default) core profile.
 *
 */
#version 330 core


/* The input texture coordinates for the sampling:
 *
 */
in vec3 tex_coords;


/* User-defined output data (the only result of each instance of fragment
 * shader), as 4 floating-point coordinates in [0.0, 1.0] (see
 * gui_color:render_rgba_color()) for the fragment of interest; no layout
 * specified here:
 *
 */
out vec4 result_color;


/* Just defined to test the uniform support (will not be found if not explicitly
 * used afterwards):
 *
 */
uniform vec3 some_color;


/* The fragment shader must now the texture of interest, in order to fetch
 * texels from it based on the texture coordinates that it processes:
 *
 */
uniform sampler2D my_texture;


void main()
{

	// For all fragments, the output color will be pure green:
	//my_color = vec3(0.0, 0.1, 0.0);

	/* For all fragments, the output color will be determined by sampling
	 * the corresponding texture:
	 *
	 * (texture/2 is a GLSL built-in texture function)
	 *
	 */
	result_color = texture( my_texture, tex_coords );
}